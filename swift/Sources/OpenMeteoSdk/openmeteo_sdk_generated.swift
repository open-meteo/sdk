// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

import FlatBuffers

public enum openmeteo_sdk_SiUnit: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case celsius = 1
  case fahrenheit = 2
  case kelvin = 3
  case kmh = 4
  case mph = 5
  case knots = 6
  case ms = 7
  case msNotUnitConverted = 8
  case millimeter = 9
  case centimeter = 10
  case inch = 11
  case feet = 12
  case meter = 13
  case gpm = 14
  case percent = 15
  case hectoPascal = 16
  case pascal = 17
  case degreeDirection = 18
  case wmoCode = 19
  case wattPerSquareMeter = 20
  case kilogramPerSquareMeter = 21
  case gramPerKilogram = 22
  case perSecond = 23
  case second = 24
  case qubicMeterPerQubicMeter = 25
  case qubicMeterPerSecond = 26
  case kiloPascal = 27
  case megaJoulesPerSquareMeter = 28
  case joulesPerKilogram = 29
  case hours = 30
  case iso8601 = 31
  case unixtime = 32
  case microgramsPerQuibicMeter = 33
  case grainsPerQuibicMeter = 34
  case dimensionless = 35
  case dimensionlessInteger = 36
  case eaqi = 37
  case usaqi = 38
  case gddCelsius = 39
  case fraction = 40

  public static var max: openmeteo_sdk_SiUnit { return .fraction }
  public static var min: openmeteo_sdk_SiUnit { return .undefined }
}


public enum openmeteo_sdk_Model: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case bestMatch = 1
  case gfsSeamless = 2
  case gfsGlobal = 3
  case gfsHrrr = 4
  case meteofranceSeamless = 5
  case meteofranceArpegeSeamless = 6
  case meteofranceArpegeWorld = 7
  case meteofranceArpegeEurope = 8
  case meteofranceAromeSeamless = 9
  case meteofranceAromeFrance = 10
  case meteofranceAromeFranceHd = 11
  case jmaSeamless = 12
  case jmaMsm = 13
  case jmsGsm = 14
  case jmaGsm = 15
  case gemSeamless = 16
  case gemGlobal = 17
  case gemRegional = 18
  case gemHrdpsContinental = 19
  case iconSeamless = 20
  case iconGlobal = 21
  case iconEu = 22
  case iconD2 = 23
  case ecmwfIfs04 = 24
  case metnoNordic = 25
  case era5Seamless = 26
  case era5 = 27
  case cerra = 28
  case era5Land = 29
  case ecmwfIfs = 30
  case gwam = 31
  case ewam = 32
  case glofasSeamlessV3 = 33
  case glofasForecastV3 = 34
  case glofasConsolidatedV3 = 35
  case glofasSeamlessV4 = 36
  case glofasForecastV4 = 37
  case glofasConsolidatedV4 = 38
  case gfs025 = 39
  case gfs05 = 40
  case cmccCm2Vhr4 = 41
  case fgoalsF3HHighressst = 42
  case fgoalsF3H = 43
  case hiramSitHr = 44
  case mriAgcm32S = 45
  case ecEarth3pHr = 46
  case mpiEsm12Xr = 47
  case nicam168s = 48
  case camsEurope = 49
  case camsGlobal = 50

  public static var max: openmeteo_sdk_Model { return .camsGlobal }
  public static var min: openmeteo_sdk_Model { return .undefined }
}


public enum openmeteo_sdk_Variable: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case undefined = 0
  case apparentTemperature = 1
  case cape = 2
  case cloudcover = 3
  case cloudcoverHigh = 4
  case cloudcoverLow = 5
  case cloudcoverMid = 6
  case dewpoint = 7
  case diffuseRadiation = 8
  case diffuseRadiationInstant = 9
  case directNormalIrradiance = 10
  case directNormalIrradianceInstant = 11
  case directRadiation = 12
  case directRadiationInstant = 13
  case et0FaoEvapotranspiration = 14
  case evapotranspiration = 15
  case freezinglevelHeight = 16
  case growingDegreeDays = 17
  case isDay = 18
  case latentHeatflux = 19
  case leafWetnessProbability = 20
  case liftedIndex = 21
  case lightningPotential = 22
  case precipitation = 23
  case precipitationProbability = 24
  case pressureMsl = 25
  case rain = 26
  case relativehumidity = 27
  case runoff = 28
  case sensibleHeatflux = 29
  case shortwaveRadiation = 30
  case shortwaveRadiationInstant = 31
  case showers = 32
  case snowDepth = 33
  case snowHeight = 34
  case snowfall = 35
  case snowfallHeight = 36
  case snowfallWaterEquivalent = 37
  case soilMoisture = 38
  case soilMoistureIndex = 39
  case soilTemperature = 40
  case surfacePressure = 41
  case surfaceTemperature = 42
  case temperature = 43
  case terrestrialRadiation = 44
  case terrestrialRadiationInstant = 45
  case totalColumnIntegratedWaterVapour = 46
  case updraft = 47
  case uvIndex = 48
  case uvIndexClearSky = 49
  case vaporPressureDeficit = 50
  case visibility = 51
  case weathercode = 52
  case winddirection = 53
  case windgusts = 54
  case windspeed = 55
  case verticalVelocity = 56
  case geopotentialHeight = 57
  case wetBulbTemperature = 58
  case riverDischarge = 59
  case waveHeight = 60
  case wavePeriod = 61
  case waveDirection = 62
  case windWaveHeight = 63
  case windWavePeriod = 64
  case windWavePeakPeriod = 65
  case windWaveDirection = 66
  case swellWaveHeight = 67
  case swellWavePeriod = 68
  case swellWavePeakPeriod = 69
  case swellWaveDirection = 70
  case pm10 = 71
  case pm2p5 = 72
  case dust = 73
  case aerosolOpticalDepth = 74
  case carbonMonoxide = 75
  case nitrogenDioxide = 76
  case ammonia = 77
  case ozone = 78
  case sulphurDioxide = 79
  case alderPollen = 80
  case birchPollen = 81
  case grassPollen = 82
  case mugwortPollen = 83
  case olivePollen = 84
  case ragweedPollen = 85
  case europeanAqi = 86
  case europeanAqiPm2p5 = 87
  case europeanAqiPm10 = 88
  case europeanAqiNo2 = 89
  case europeanAqiO3 = 90
  case europeanAqiSo2 = 91
  case usAqi = 92
  case usAqiPm2p5 = 93
  case usAqiPm10 = 94
  case usAqiNo2 = 95
  case usAqiO3 = 96
  case usAqiSo2 = 97
  case usAqiCo = 98

  public static var max: openmeteo_sdk_Variable { return .usAqiCo }
  public static var min: openmeteo_sdk_Variable { return .undefined }
}


public enum openmeteo_sdk_Aggregation: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case none_ = 0
  case minimum = 1
  case maximum = 2
  case mean = 3
  case p10 = 4
  case p25 = 5
  case median = 6
  case p75 = 7
  case p90 = 8
  case dominant = 9

  public static var max: openmeteo_sdk_Aggregation { return .dominant }
  public static var min: openmeteo_sdk_Aggregation { return .none_ }
}


public struct openmeteo_sdk_Series: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case variable = 4
    case unit = 6
    case aggregation = 8
    case altitude = 10
    case pressureLevel = 12
    case depth = 14
    case depthTo = 16
    case ensembleMember = 18
    case value = 20
    case values = 22
    case valuesInt64 = 24
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var variable: openmeteo_sdk_Variable { let o = _accessor.offset(VTOFFSET.variable.v); return o == 0 ? .undefined : openmeteo_sdk_Variable(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var unit: openmeteo_sdk_SiUnit { let o = _accessor.offset(VTOFFSET.unit.v); return o == 0 ? .undefined : openmeteo_sdk_SiUnit(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var aggregation: openmeteo_sdk_Aggregation { let o = _accessor.offset(VTOFFSET.aggregation.v); return o == 0 ? .none_ : openmeteo_sdk_Aggregation(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .none_ }
  public var altitude: Int16 { let o = _accessor.offset(VTOFFSET.altitude.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var pressureLevel: Int16 { let o = _accessor.offset(VTOFFSET.pressureLevel.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var depth: Int16 { let o = _accessor.offset(VTOFFSET.depth.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var depthTo: Int16 { let o = _accessor.offset(VTOFFSET.depthTo.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var ensembleMember: Int16 { let o = _accessor.offset(VTOFFSET.ensembleMember.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int16.self, at: o) }
  public var value: Float32 { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var hasValues: Bool { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? false : true }
  public var valuesCount: Int32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func values(at index: Int32) -> Float32 { let o = _accessor.offset(VTOFFSET.values.v); return o == 0 ? 0 : _accessor.directRead(of: Float32.self, offset: _accessor.vector(at: o) + index * 4) }
  public var values: [Float32] { return _accessor.getVector(at: VTOFFSET.values.v) ?? [] }
  public var hasValuesInt64: Bool { let o = _accessor.offset(VTOFFSET.valuesInt64.v); return o == 0 ? false : true }
  public var valuesInt64Count: Int32 { let o = _accessor.offset(VTOFFSET.valuesInt64.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func valuesInt64(at index: Int32) -> Int64 { let o = _accessor.offset(VTOFFSET.valuesInt64.v); return o == 0 ? 0 : _accessor.directRead(of: Int64.self, offset: _accessor.vector(at: o) + index * 8) }
  public var valuesInt64: [Int64] { return _accessor.getVector(at: VTOFFSET.valuesInt64.v) ?? [] }
  public static func startSeries(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 11) }
  public static func add(variable: openmeteo_sdk_Variable, _ fbb: inout FlatBufferBuilder) { fbb.add(element: variable.rawValue, def: 0, at: VTOFFSET.variable.p) }
  public static func add(unit: openmeteo_sdk_SiUnit, _ fbb: inout FlatBufferBuilder) { fbb.add(element: unit.rawValue, def: 0, at: VTOFFSET.unit.p) }
  public static func add(aggregation: openmeteo_sdk_Aggregation, _ fbb: inout FlatBufferBuilder) { fbb.add(element: aggregation.rawValue, def: 0, at: VTOFFSET.aggregation.p) }
  public static func add(altitude: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: altitude, def: 0, at: VTOFFSET.altitude.p) }
  public static func add(pressureLevel: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: pressureLevel, def: 0, at: VTOFFSET.pressureLevel.p) }
  public static func add(depth: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depth, def: 0, at: VTOFFSET.depth.p) }
  public static func add(depthTo: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: depthTo, def: 0, at: VTOFFSET.depthTo.p) }
  public static func add(ensembleMember: Int16, _ fbb: inout FlatBufferBuilder) { fbb.add(element: ensembleMember, def: 0, at: VTOFFSET.ensembleMember.p) }
  public static func add(value: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: value, def: 0.0, at: VTOFFSET.value.p) }
  public static func addVectorOf(values: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: values, at: VTOFFSET.values.p) }
  public static func addVectorOf(valuesInt64: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: valuesInt64, at: VTOFFSET.valuesInt64.p) }
  public static func endSeries(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSeries(
    _ fbb: inout FlatBufferBuilder,
    variable: openmeteo_sdk_Variable = .undefined,
    unit: openmeteo_sdk_SiUnit = .undefined,
    aggregation: openmeteo_sdk_Aggregation = .none_,
    altitude: Int16 = 0,
    pressureLevel: Int16 = 0,
    depth: Int16 = 0,
    depthTo: Int16 = 0,
    ensembleMember: Int16 = 0,
    value: Float32 = 0.0,
    valuesVectorOffset values: Offset = Offset(),
    valuesInt64VectorOffset valuesInt64: Offset = Offset()
  ) -> Offset {
    let __start = openmeteo_sdk_Series.startSeries(&fbb)
    openmeteo_sdk_Series.add(variable: variable, &fbb)
    openmeteo_sdk_Series.add(unit: unit, &fbb)
    openmeteo_sdk_Series.add(aggregation: aggregation, &fbb)
    openmeteo_sdk_Series.add(altitude: altitude, &fbb)
    openmeteo_sdk_Series.add(pressureLevel: pressureLevel, &fbb)
    openmeteo_sdk_Series.add(depth: depth, &fbb)
    openmeteo_sdk_Series.add(depthTo: depthTo, &fbb)
    openmeteo_sdk_Series.add(ensembleMember: ensembleMember, &fbb)
    openmeteo_sdk_Series.add(value: value, &fbb)
    openmeteo_sdk_Series.addVectorOf(values: values, &fbb)
    openmeteo_sdk_Series.addVectorOf(valuesInt64: valuesInt64, &fbb)
    return openmeteo_sdk_Series.endSeries(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.variable.p, fieldName: "variable", required: false, type: openmeteo_sdk_Variable.self)
    try _v.visit(field: VTOFFSET.unit.p, fieldName: "unit", required: false, type: openmeteo_sdk_SiUnit.self)
    try _v.visit(field: VTOFFSET.aggregation.p, fieldName: "aggregation", required: false, type: openmeteo_sdk_Aggregation.self)
    try _v.visit(field: VTOFFSET.altitude.p, fieldName: "altitude", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.pressureLevel.p, fieldName: "pressureLevel", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.depth.p, fieldName: "depth", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.depthTo.p, fieldName: "depthTo", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.ensembleMember.p, fieldName: "ensembleMember", required: false, type: Int16.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.values.p, fieldName: "values", required: false, type: ForwardOffset<Vector<Float32, Float32>>.self)
    try _v.visit(field: VTOFFSET.valuesInt64.p, fieldName: "valuesInt64", required: false, type: ForwardOffset<Vector<Int64, Int64>>.self)
    _v.finish()
  }
}

public struct openmeteo_sdk_SeriesAndTime: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case start = 4
    case end = 6
    case interval = 8
    case series = 10
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var start: Int64 { let o = _accessor.offset(VTOFFSET.start.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var end: Int64 { let o = _accessor.offset(VTOFFSET.end.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int64.self, at: o) }
  public var interval: Int32 { let o = _accessor.offset(VTOFFSET.interval.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var hasSeries: Bool { let o = _accessor.offset(VTOFFSET.series.v); return o == 0 ? false : true }
  public var seriesCount: Int32 { let o = _accessor.offset(VTOFFSET.series.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func series(at index: Int32) -> openmeteo_sdk_Series? { let o = _accessor.offset(VTOFFSET.series.v); return o == 0 ? nil : openmeteo_sdk_Series(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startSeriesAndTime(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 4) }
  public static func add(start: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: start, def: 0, at: VTOFFSET.start.p) }
  public static func add(end: Int64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: end, def: 0, at: VTOFFSET.end.p) }
  public static func add(interval: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: interval, def: 0, at: VTOFFSET.interval.p) }
  public static func addVectorOf(series: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: series, at: VTOFFSET.series.p) }
  public static func endSeriesAndTime(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSeriesAndTime(
    _ fbb: inout FlatBufferBuilder,
    start: Int64 = 0,
    end: Int64 = 0,
    interval: Int32 = 0,
    seriesVectorOffset series: Offset = Offset()
  ) -> Offset {
    let __start = openmeteo_sdk_SeriesAndTime.startSeriesAndTime(&fbb)
    openmeteo_sdk_SeriesAndTime.add(start: start, &fbb)
    openmeteo_sdk_SeriesAndTime.add(end: end, &fbb)
    openmeteo_sdk_SeriesAndTime.add(interval: interval, &fbb)
    openmeteo_sdk_SeriesAndTime.addVectorOf(series: series, &fbb)
    return openmeteo_sdk_SeriesAndTime.endSeriesAndTime(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.start.p, fieldName: "start", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.end.p, fieldName: "end", required: false, type: Int64.self)
    try _v.visit(field: VTOFFSET.interval.p, fieldName: "interval", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.series.p, fieldName: "series", required: false, type: ForwardOffset<Vector<ForwardOffset<openmeteo_sdk_Series>, openmeteo_sdk_Series>>.self)
    _v.finish()
  }
}

public struct openmeteo_sdk_ApiResponse: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_23_5_26() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case latitude = 4
    case longitude = 6
    case elevation = 8
    case locationId = 10
    case model = 12
    case generationtimeMs = 14
    case utcOffsetSeconds = 16
    case timezone = 18
    case timezoneAbbreviation = 20
    case current = 22
    case daily = 24
    case hourly = 26
    case sixHourly = 28
    case minutely15 = 30
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var latitude: Float32 { let o = _accessor.offset(VTOFFSET.latitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var longitude: Float32 { let o = _accessor.offset(VTOFFSET.longitude.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var elevation: Float32 { let o = _accessor.offset(VTOFFSET.elevation.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var locationId: Int32 { let o = _accessor.offset(VTOFFSET.locationId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var model: openmeteo_sdk_Model { let o = _accessor.offset(VTOFFSET.model.v); return o == 0 ? .undefined : openmeteo_sdk_Model(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .undefined }
  public var generationtimeMs: Float32 { let o = _accessor.offset(VTOFFSET.generationtimeMs.v); return o == 0 ? 0.0 : _accessor.readBuffer(of: Float32.self, at: o) }
  public var utcOffsetSeconds: Int32 { let o = _accessor.offset(VTOFFSET.utcOffsetSeconds.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var timezone: String? { let o = _accessor.offset(VTOFFSET.timezone.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var timezoneSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.timezone.v) }
  public var timezoneAbbreviation: String? { let o = _accessor.offset(VTOFFSET.timezoneAbbreviation.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var timezoneAbbreviationSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.timezoneAbbreviation.v) }
  public var current: openmeteo_sdk_SeriesAndTime? { let o = _accessor.offset(VTOFFSET.current.v); return o == 0 ? nil : openmeteo_sdk_SeriesAndTime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var daily: openmeteo_sdk_SeriesAndTime? { let o = _accessor.offset(VTOFFSET.daily.v); return o == 0 ? nil : openmeteo_sdk_SeriesAndTime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var hourly: openmeteo_sdk_SeriesAndTime? { let o = _accessor.offset(VTOFFSET.hourly.v); return o == 0 ? nil : openmeteo_sdk_SeriesAndTime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var sixHourly: openmeteo_sdk_SeriesAndTime? { let o = _accessor.offset(VTOFFSET.sixHourly.v); return o == 0 ? nil : openmeteo_sdk_SeriesAndTime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public var minutely15: openmeteo_sdk_SeriesAndTime? { let o = _accessor.offset(VTOFFSET.minutely15.v); return o == 0 ? nil : openmeteo_sdk_SeriesAndTime(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
  public static func startApiResponse(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 14) }
  public static func add(latitude: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: latitude, def: 0.0, at: VTOFFSET.latitude.p) }
  public static func add(longitude: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: longitude, def: 0.0, at: VTOFFSET.longitude.p) }
  public static func add(elevation: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: elevation, def: 0.0, at: VTOFFSET.elevation.p) }
  public static func add(locationId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: locationId, def: 0, at: VTOFFSET.locationId.p) }
  public static func add(model: openmeteo_sdk_Model, _ fbb: inout FlatBufferBuilder) { fbb.add(element: model.rawValue, def: 0, at: VTOFFSET.model.p) }
  public static func add(generationtimeMs: Float32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: generationtimeMs, def: 0.0, at: VTOFFSET.generationtimeMs.p) }
  public static func add(utcOffsetSeconds: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: utcOffsetSeconds, def: 0, at: VTOFFSET.utcOffsetSeconds.p) }
  public static func add(timezone: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: timezone, at: VTOFFSET.timezone.p) }
  public static func add(timezoneAbbreviation: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: timezoneAbbreviation, at: VTOFFSET.timezoneAbbreviation.p) }
  public static func add(current: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: current, at: VTOFFSET.current.p) }
  public static func add(daily: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: daily, at: VTOFFSET.daily.p) }
  public static func add(hourly: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: hourly, at: VTOFFSET.hourly.p) }
  public static func add(sixHourly: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: sixHourly, at: VTOFFSET.sixHourly.p) }
  public static func add(minutely15: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: minutely15, at: VTOFFSET.minutely15.p) }
  public static func endApiResponse(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createApiResponse(
    _ fbb: inout FlatBufferBuilder,
    latitude: Float32 = 0.0,
    longitude: Float32 = 0.0,
    elevation: Float32 = 0.0,
    locationId: Int32 = 0,
    model: openmeteo_sdk_Model = .undefined,
    generationtimeMs: Float32 = 0.0,
    utcOffsetSeconds: Int32 = 0,
    timezoneOffset timezone: Offset = Offset(),
    timezoneAbbreviationOffset timezoneAbbreviation: Offset = Offset(),
    currentOffset current: Offset = Offset(),
    dailyOffset daily: Offset = Offset(),
    hourlyOffset hourly: Offset = Offset(),
    sixHourlyOffset sixHourly: Offset = Offset(),
    minutely15Offset minutely15: Offset = Offset()
  ) -> Offset {
    let __start = openmeteo_sdk_ApiResponse.startApiResponse(&fbb)
    openmeteo_sdk_ApiResponse.add(latitude: latitude, &fbb)
    openmeteo_sdk_ApiResponse.add(longitude: longitude, &fbb)
    openmeteo_sdk_ApiResponse.add(elevation: elevation, &fbb)
    openmeteo_sdk_ApiResponse.add(locationId: locationId, &fbb)
    openmeteo_sdk_ApiResponse.add(model: model, &fbb)
    openmeteo_sdk_ApiResponse.add(generationtimeMs: generationtimeMs, &fbb)
    openmeteo_sdk_ApiResponse.add(utcOffsetSeconds: utcOffsetSeconds, &fbb)
    openmeteo_sdk_ApiResponse.add(timezone: timezone, &fbb)
    openmeteo_sdk_ApiResponse.add(timezoneAbbreviation: timezoneAbbreviation, &fbb)
    openmeteo_sdk_ApiResponse.add(current: current, &fbb)
    openmeteo_sdk_ApiResponse.add(daily: daily, &fbb)
    openmeteo_sdk_ApiResponse.add(hourly: hourly, &fbb)
    openmeteo_sdk_ApiResponse.add(sixHourly: sixHourly, &fbb)
    openmeteo_sdk_ApiResponse.add(minutely15: minutely15, &fbb)
    return openmeteo_sdk_ApiResponse.endApiResponse(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.latitude.p, fieldName: "latitude", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.longitude.p, fieldName: "longitude", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.elevation.p, fieldName: "elevation", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.locationId.p, fieldName: "locationId", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.model.p, fieldName: "model", required: false, type: openmeteo_sdk_Model.self)
    try _v.visit(field: VTOFFSET.generationtimeMs.p, fieldName: "generationtimeMs", required: false, type: Float32.self)
    try _v.visit(field: VTOFFSET.utcOffsetSeconds.p, fieldName: "utcOffsetSeconds", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.timezone.p, fieldName: "timezone", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.timezoneAbbreviation.p, fieldName: "timezoneAbbreviation", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.current.p, fieldName: "current", required: false, type: ForwardOffset<openmeteo_sdk_SeriesAndTime>.self)
    try _v.visit(field: VTOFFSET.daily.p, fieldName: "daily", required: false, type: ForwardOffset<openmeteo_sdk_SeriesAndTime>.self)
    try _v.visit(field: VTOFFSET.hourly.p, fieldName: "hourly", required: false, type: ForwardOffset<openmeteo_sdk_SeriesAndTime>.self)
    try _v.visit(field: VTOFFSET.sixHourly.p, fieldName: "sixHourly", required: false, type: ForwardOffset<openmeteo_sdk_SeriesAndTime>.self)
    try _v.visit(field: VTOFFSET.minutely15.p, fieldName: "minutely15", required: false, type: ForwardOffset<openmeteo_sdk_SeriesAndTime>.self)
    _v.finish()
  }
}


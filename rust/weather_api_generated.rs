// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod openmeteo_sdk {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_UNIT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_UNIT: u8 = 40;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_UNIT: [Unit; 41] = [
  Unit::undefined,
  Unit::celsius,
  Unit::centimetre,
  Unit::cubic_metre_per_cubic_metre,
  Unit::cubic_metre_per_second,
  Unit::degree_direction,
  Unit::dimensionless_integer,
  Unit::dimensionless,
  Unit::european_air_quality_index,
  Unit::fahrenheit,
  Unit::feet,
  Unit::fraction,
  Unit::gdd_celsius,
  Unit::geopotential_metre,
  Unit::grains_per_cubic_metre,
  Unit::gram_per_kilogram,
  Unit::hectopascal,
  Unit::hours,
  Unit::inch,
  Unit::iso8601,
  Unit::joule_per_kilogram,
  Unit::kelvin,
  Unit::kilopascal,
  Unit::kilogram_per_square_metre,
  Unit::kilometres_per_hour,
  Unit::knots,
  Unit::megajoule_per_square_metre,
  Unit::metre_per_second_not_unit_converted,
  Unit::metre_per_second,
  Unit::metre,
  Unit::micrograms_per_cubic_metre,
  Unit::miles_per_hour,
  Unit::millimetre,
  Unit::pascal,
  Unit::per_second,
  Unit::percentage,
  Unit::seconds,
  Unit::unix_time,
  Unit::us_air_quality_index,
  Unit::watt_per_square_metre,
  Unit::wmo_code,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Unit(pub u8);
#[allow(non_upper_case_globals)]
impl Unit {
  pub const undefined: Self = Self(0);
  pub const celsius: Self = Self(1);
  pub const centimetre: Self = Self(2);
  pub const cubic_metre_per_cubic_metre: Self = Self(3);
  pub const cubic_metre_per_second: Self = Self(4);
  pub const degree_direction: Self = Self(5);
  pub const dimensionless_integer: Self = Self(6);
  pub const dimensionless: Self = Self(7);
  pub const european_air_quality_index: Self = Self(8);
  pub const fahrenheit: Self = Self(9);
  pub const feet: Self = Self(10);
  pub const fraction: Self = Self(11);
  pub const gdd_celsius: Self = Self(12);
  pub const geopotential_metre: Self = Self(13);
  pub const grains_per_cubic_metre: Self = Self(14);
  pub const gram_per_kilogram: Self = Self(15);
  pub const hectopascal: Self = Self(16);
  pub const hours: Self = Self(17);
  pub const inch: Self = Self(18);
  pub const iso8601: Self = Self(19);
  pub const joule_per_kilogram: Self = Self(20);
  pub const kelvin: Self = Self(21);
  pub const kilopascal: Self = Self(22);
  pub const kilogram_per_square_metre: Self = Self(23);
  pub const kilometres_per_hour: Self = Self(24);
  pub const knots: Self = Self(25);
  pub const megajoule_per_square_metre: Self = Self(26);
  pub const metre_per_second_not_unit_converted: Self = Self(27);
  pub const metre_per_second: Self = Self(28);
  pub const metre: Self = Self(29);
  pub const micrograms_per_cubic_metre: Self = Self(30);
  pub const miles_per_hour: Self = Self(31);
  pub const millimetre: Self = Self(32);
  pub const pascal: Self = Self(33);
  pub const per_second: Self = Self(34);
  pub const percentage: Self = Self(35);
  pub const seconds: Self = Self(36);
  pub const unix_time: Self = Self(37);
  pub const us_air_quality_index: Self = Self(38);
  pub const watt_per_square_metre: Self = Self(39);
  pub const wmo_code: Self = Self(40);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 40;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::undefined,
    Self::celsius,
    Self::centimetre,
    Self::cubic_metre_per_cubic_metre,
    Self::cubic_metre_per_second,
    Self::degree_direction,
    Self::dimensionless_integer,
    Self::dimensionless,
    Self::european_air_quality_index,
    Self::fahrenheit,
    Self::feet,
    Self::fraction,
    Self::gdd_celsius,
    Self::geopotential_metre,
    Self::grains_per_cubic_metre,
    Self::gram_per_kilogram,
    Self::hectopascal,
    Self::hours,
    Self::inch,
    Self::iso8601,
    Self::joule_per_kilogram,
    Self::kelvin,
    Self::kilopascal,
    Self::kilogram_per_square_metre,
    Self::kilometres_per_hour,
    Self::knots,
    Self::megajoule_per_square_metre,
    Self::metre_per_second_not_unit_converted,
    Self::metre_per_second,
    Self::metre,
    Self::micrograms_per_cubic_metre,
    Self::miles_per_hour,
    Self::millimetre,
    Self::pascal,
    Self::per_second,
    Self::percentage,
    Self::seconds,
    Self::unix_time,
    Self::us_air_quality_index,
    Self::watt_per_square_metre,
    Self::wmo_code,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::undefined => Some("undefined"),
      Self::celsius => Some("celsius"),
      Self::centimetre => Some("centimetre"),
      Self::cubic_metre_per_cubic_metre => Some("cubic_metre_per_cubic_metre"),
      Self::cubic_metre_per_second => Some("cubic_metre_per_second"),
      Self::degree_direction => Some("degree_direction"),
      Self::dimensionless_integer => Some("dimensionless_integer"),
      Self::dimensionless => Some("dimensionless"),
      Self::european_air_quality_index => Some("european_air_quality_index"),
      Self::fahrenheit => Some("fahrenheit"),
      Self::feet => Some("feet"),
      Self::fraction => Some("fraction"),
      Self::gdd_celsius => Some("gdd_celsius"),
      Self::geopotential_metre => Some("geopotential_metre"),
      Self::grains_per_cubic_metre => Some("grains_per_cubic_metre"),
      Self::gram_per_kilogram => Some("gram_per_kilogram"),
      Self::hectopascal => Some("hectopascal"),
      Self::hours => Some("hours"),
      Self::inch => Some("inch"),
      Self::iso8601 => Some("iso8601"),
      Self::joule_per_kilogram => Some("joule_per_kilogram"),
      Self::kelvin => Some("kelvin"),
      Self::kilopascal => Some("kilopascal"),
      Self::kilogram_per_square_metre => Some("kilogram_per_square_metre"),
      Self::kilometres_per_hour => Some("kilometres_per_hour"),
      Self::knots => Some("knots"),
      Self::megajoule_per_square_metre => Some("megajoule_per_square_metre"),
      Self::metre_per_second_not_unit_converted => Some("metre_per_second_not_unit_converted"),
      Self::metre_per_second => Some("metre_per_second"),
      Self::metre => Some("metre"),
      Self::micrograms_per_cubic_metre => Some("micrograms_per_cubic_metre"),
      Self::miles_per_hour => Some("miles_per_hour"),
      Self::millimetre => Some("millimetre"),
      Self::pascal => Some("pascal"),
      Self::per_second => Some("per_second"),
      Self::percentage => Some("percentage"),
      Self::seconds => Some("seconds"),
      Self::unix_time => Some("unix_time"),
      Self::us_air_quality_index => Some("us_air_quality_index"),
      Self::watt_per_square_metre => Some("watt_per_square_metre"),
      Self::wmo_code => Some("wmo_code"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Unit {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Unit {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Unit {
    type Output = Unit;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Unit {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Unit {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Unit {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MODEL: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MODEL: u8 = 82;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MODEL: [Model; 83] = [
  Model::undefined,
  Model::best_match,
  Model::gfs_seamless,
  Model::gfs_global,
  Model::gfs_hrrr,
  Model::meteofrance_seamless,
  Model::meteofrance_arpege_seamless,
  Model::meteofrance_arpege_world,
  Model::meteofrance_arpege_europe,
  Model::meteofrance_arome_seamless,
  Model::meteofrance_arome_france,
  Model::meteofrance_arome_france_hd,
  Model::jma_seamless,
  Model::jma_msm,
  Model::jms_gsm,
  Model::jma_gsm,
  Model::gem_seamless,
  Model::gem_global,
  Model::gem_regional,
  Model::gem_hrdps_continental,
  Model::icon_seamless,
  Model::icon_global,
  Model::icon_eu,
  Model::icon_d2,
  Model::ecmwf_ifs04,
  Model::metno_nordic,
  Model::era5_seamless,
  Model::era5,
  Model::cerra,
  Model::era5_land,
  Model::ecmwf_ifs,
  Model::gwam,
  Model::ewam,
  Model::glofas_seamless_v3,
  Model::glofas_forecast_v3,
  Model::glofas_consolidated_v3,
  Model::glofas_seamless_v4,
  Model::glofas_forecast_v4,
  Model::glofas_consolidated_v4,
  Model::gfs025,
  Model::gfs05,
  Model::CMCC_CM2_VHR4,
  Model::FGOALS_f3_H_highresSST,
  Model::FGOALS_f3_H,
  Model::HiRAM_SIT_HR,
  Model::MRI_AGCM3_2_S,
  Model::EC_Earth3P_HR,
  Model::MPI_ESM1_2_XR,
  Model::NICAM16_8S,
  Model::cams_europe,
  Model::cams_global,
  Model::cfsv2,
  Model::era5_ocean,
  Model::cma_grapes_global,
  Model::bom_access_global,
  Model::bom_access_global_ensemble,
  Model::arpae_cosmo_seamless,
  Model::arpae_cosmo_2i,
  Model::arpae_cosmo_2i_ruc,
  Model::arpae_cosmo_5m,
  Model::ecmwf_ifs025,
  Model::ecmwf_aifs025,
  Model::gfs013,
  Model::gfs_graphcast025,
  Model::ecmwf_wam025,
  Model::meteofrance_wave,
  Model::meteofrance_currents,
  Model::ecmwf_wam025_ensemble,
  Model::ncep_gfswave025,
  Model::ncep_gefswave025,
  Model::knmi_seamless,
  Model::knmi_harmonie_arome_europe,
  Model::knmi_harmonie_arome_netherlands,
  Model::dmi_seamless,
  Model::dmi_harmonie_arome_europe,
  Model::metno_seamless,
  Model::era5_ensemble,
  Model::ecmwf_ifs_analysis,
  Model::ecmwf_ifs_long_window,
  Model::ecmwf_ifs_analysis_long_window,
  Model::ukmo_global_deterministic_10km,
  Model::ukmo_uk_deterministic_2km,
  Model::ukmo_seamless,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Model(pub u8);
#[allow(non_upper_case_globals)]
impl Model {
  pub const undefined: Self = Self(0);
  pub const best_match: Self = Self(1);
  pub const gfs_seamless: Self = Self(2);
  pub const gfs_global: Self = Self(3);
  pub const gfs_hrrr: Self = Self(4);
  pub const meteofrance_seamless: Self = Self(5);
  pub const meteofrance_arpege_seamless: Self = Self(6);
  pub const meteofrance_arpege_world: Self = Self(7);
  pub const meteofrance_arpege_europe: Self = Self(8);
  pub const meteofrance_arome_seamless: Self = Self(9);
  pub const meteofrance_arome_france: Self = Self(10);
  pub const meteofrance_arome_france_hd: Self = Self(11);
  pub const jma_seamless: Self = Self(12);
  pub const jma_msm: Self = Self(13);
  pub const jms_gsm: Self = Self(14);
  pub const jma_gsm: Self = Self(15);
  pub const gem_seamless: Self = Self(16);
  pub const gem_global: Self = Self(17);
  pub const gem_regional: Self = Self(18);
  pub const gem_hrdps_continental: Self = Self(19);
  pub const icon_seamless: Self = Self(20);
  pub const icon_global: Self = Self(21);
  pub const icon_eu: Self = Self(22);
  pub const icon_d2: Self = Self(23);
  pub const ecmwf_ifs04: Self = Self(24);
  pub const metno_nordic: Self = Self(25);
  pub const era5_seamless: Self = Self(26);
  pub const era5: Self = Self(27);
  pub const cerra: Self = Self(28);
  pub const era5_land: Self = Self(29);
  pub const ecmwf_ifs: Self = Self(30);
  pub const gwam: Self = Self(31);
  pub const ewam: Self = Self(32);
  pub const glofas_seamless_v3: Self = Self(33);
  pub const glofas_forecast_v3: Self = Self(34);
  pub const glofas_consolidated_v3: Self = Self(35);
  pub const glofas_seamless_v4: Self = Self(36);
  pub const glofas_forecast_v4: Self = Self(37);
  pub const glofas_consolidated_v4: Self = Self(38);
  pub const gfs025: Self = Self(39);
  pub const gfs05: Self = Self(40);
  pub const CMCC_CM2_VHR4: Self = Self(41);
  pub const FGOALS_f3_H_highresSST: Self = Self(42);
  pub const FGOALS_f3_H: Self = Self(43);
  pub const HiRAM_SIT_HR: Self = Self(44);
  pub const MRI_AGCM3_2_S: Self = Self(45);
  pub const EC_Earth3P_HR: Self = Self(46);
  pub const MPI_ESM1_2_XR: Self = Self(47);
  pub const NICAM16_8S: Self = Self(48);
  pub const cams_europe: Self = Self(49);
  pub const cams_global: Self = Self(50);
  pub const cfsv2: Self = Self(51);
  pub const era5_ocean: Self = Self(52);
  pub const cma_grapes_global: Self = Self(53);
  pub const bom_access_global: Self = Self(54);
  pub const bom_access_global_ensemble: Self = Self(55);
  pub const arpae_cosmo_seamless: Self = Self(56);
  pub const arpae_cosmo_2i: Self = Self(57);
  pub const arpae_cosmo_2i_ruc: Self = Self(58);
  pub const arpae_cosmo_5m: Self = Self(59);
  pub const ecmwf_ifs025: Self = Self(60);
  pub const ecmwf_aifs025: Self = Self(61);
  pub const gfs013: Self = Self(62);
  pub const gfs_graphcast025: Self = Self(63);
  pub const ecmwf_wam025: Self = Self(64);
  pub const meteofrance_wave: Self = Self(65);
  pub const meteofrance_currents: Self = Self(66);
  pub const ecmwf_wam025_ensemble: Self = Self(67);
  pub const ncep_gfswave025: Self = Self(68);
  pub const ncep_gefswave025: Self = Self(69);
  pub const knmi_seamless: Self = Self(70);
  pub const knmi_harmonie_arome_europe: Self = Self(71);
  pub const knmi_harmonie_arome_netherlands: Self = Self(72);
  pub const dmi_seamless: Self = Self(73);
  pub const dmi_harmonie_arome_europe: Self = Self(74);
  pub const metno_seamless: Self = Self(75);
  pub const era5_ensemble: Self = Self(76);
  pub const ecmwf_ifs_analysis: Self = Self(77);
  pub const ecmwf_ifs_long_window: Self = Self(78);
  pub const ecmwf_ifs_analysis_long_window: Self = Self(79);
  pub const ukmo_global_deterministic_10km: Self = Self(80);
  pub const ukmo_uk_deterministic_2km: Self = Self(81);
  pub const ukmo_seamless: Self = Self(82);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 82;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::undefined,
    Self::best_match,
    Self::gfs_seamless,
    Self::gfs_global,
    Self::gfs_hrrr,
    Self::meteofrance_seamless,
    Self::meteofrance_arpege_seamless,
    Self::meteofrance_arpege_world,
    Self::meteofrance_arpege_europe,
    Self::meteofrance_arome_seamless,
    Self::meteofrance_arome_france,
    Self::meteofrance_arome_france_hd,
    Self::jma_seamless,
    Self::jma_msm,
    Self::jms_gsm,
    Self::jma_gsm,
    Self::gem_seamless,
    Self::gem_global,
    Self::gem_regional,
    Self::gem_hrdps_continental,
    Self::icon_seamless,
    Self::icon_global,
    Self::icon_eu,
    Self::icon_d2,
    Self::ecmwf_ifs04,
    Self::metno_nordic,
    Self::era5_seamless,
    Self::era5,
    Self::cerra,
    Self::era5_land,
    Self::ecmwf_ifs,
    Self::gwam,
    Self::ewam,
    Self::glofas_seamless_v3,
    Self::glofas_forecast_v3,
    Self::glofas_consolidated_v3,
    Self::glofas_seamless_v4,
    Self::glofas_forecast_v4,
    Self::glofas_consolidated_v4,
    Self::gfs025,
    Self::gfs05,
    Self::CMCC_CM2_VHR4,
    Self::FGOALS_f3_H_highresSST,
    Self::FGOALS_f3_H,
    Self::HiRAM_SIT_HR,
    Self::MRI_AGCM3_2_S,
    Self::EC_Earth3P_HR,
    Self::MPI_ESM1_2_XR,
    Self::NICAM16_8S,
    Self::cams_europe,
    Self::cams_global,
    Self::cfsv2,
    Self::era5_ocean,
    Self::cma_grapes_global,
    Self::bom_access_global,
    Self::bom_access_global_ensemble,
    Self::arpae_cosmo_seamless,
    Self::arpae_cosmo_2i,
    Self::arpae_cosmo_2i_ruc,
    Self::arpae_cosmo_5m,
    Self::ecmwf_ifs025,
    Self::ecmwf_aifs025,
    Self::gfs013,
    Self::gfs_graphcast025,
    Self::ecmwf_wam025,
    Self::meteofrance_wave,
    Self::meteofrance_currents,
    Self::ecmwf_wam025_ensemble,
    Self::ncep_gfswave025,
    Self::ncep_gefswave025,
    Self::knmi_seamless,
    Self::knmi_harmonie_arome_europe,
    Self::knmi_harmonie_arome_netherlands,
    Self::dmi_seamless,
    Self::dmi_harmonie_arome_europe,
    Self::metno_seamless,
    Self::era5_ensemble,
    Self::ecmwf_ifs_analysis,
    Self::ecmwf_ifs_long_window,
    Self::ecmwf_ifs_analysis_long_window,
    Self::ukmo_global_deterministic_10km,
    Self::ukmo_uk_deterministic_2km,
    Self::ukmo_seamless,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::undefined => Some("undefined"),
      Self::best_match => Some("best_match"),
      Self::gfs_seamless => Some("gfs_seamless"),
      Self::gfs_global => Some("gfs_global"),
      Self::gfs_hrrr => Some("gfs_hrrr"),
      Self::meteofrance_seamless => Some("meteofrance_seamless"),
      Self::meteofrance_arpege_seamless => Some("meteofrance_arpege_seamless"),
      Self::meteofrance_arpege_world => Some("meteofrance_arpege_world"),
      Self::meteofrance_arpege_europe => Some("meteofrance_arpege_europe"),
      Self::meteofrance_arome_seamless => Some("meteofrance_arome_seamless"),
      Self::meteofrance_arome_france => Some("meteofrance_arome_france"),
      Self::meteofrance_arome_france_hd => Some("meteofrance_arome_france_hd"),
      Self::jma_seamless => Some("jma_seamless"),
      Self::jma_msm => Some("jma_msm"),
      Self::jms_gsm => Some("jms_gsm"),
      Self::jma_gsm => Some("jma_gsm"),
      Self::gem_seamless => Some("gem_seamless"),
      Self::gem_global => Some("gem_global"),
      Self::gem_regional => Some("gem_regional"),
      Self::gem_hrdps_continental => Some("gem_hrdps_continental"),
      Self::icon_seamless => Some("icon_seamless"),
      Self::icon_global => Some("icon_global"),
      Self::icon_eu => Some("icon_eu"),
      Self::icon_d2 => Some("icon_d2"),
      Self::ecmwf_ifs04 => Some("ecmwf_ifs04"),
      Self::metno_nordic => Some("metno_nordic"),
      Self::era5_seamless => Some("era5_seamless"),
      Self::era5 => Some("era5"),
      Self::cerra => Some("cerra"),
      Self::era5_land => Some("era5_land"),
      Self::ecmwf_ifs => Some("ecmwf_ifs"),
      Self::gwam => Some("gwam"),
      Self::ewam => Some("ewam"),
      Self::glofas_seamless_v3 => Some("glofas_seamless_v3"),
      Self::glofas_forecast_v3 => Some("glofas_forecast_v3"),
      Self::glofas_consolidated_v3 => Some("glofas_consolidated_v3"),
      Self::glofas_seamless_v4 => Some("glofas_seamless_v4"),
      Self::glofas_forecast_v4 => Some("glofas_forecast_v4"),
      Self::glofas_consolidated_v4 => Some("glofas_consolidated_v4"),
      Self::gfs025 => Some("gfs025"),
      Self::gfs05 => Some("gfs05"),
      Self::CMCC_CM2_VHR4 => Some("CMCC_CM2_VHR4"),
      Self::FGOALS_f3_H_highresSST => Some("FGOALS_f3_H_highresSST"),
      Self::FGOALS_f3_H => Some("FGOALS_f3_H"),
      Self::HiRAM_SIT_HR => Some("HiRAM_SIT_HR"),
      Self::MRI_AGCM3_2_S => Some("MRI_AGCM3_2_S"),
      Self::EC_Earth3P_HR => Some("EC_Earth3P_HR"),
      Self::MPI_ESM1_2_XR => Some("MPI_ESM1_2_XR"),
      Self::NICAM16_8S => Some("NICAM16_8S"),
      Self::cams_europe => Some("cams_europe"),
      Self::cams_global => Some("cams_global"),
      Self::cfsv2 => Some("cfsv2"),
      Self::era5_ocean => Some("era5_ocean"),
      Self::cma_grapes_global => Some("cma_grapes_global"),
      Self::bom_access_global => Some("bom_access_global"),
      Self::bom_access_global_ensemble => Some("bom_access_global_ensemble"),
      Self::arpae_cosmo_seamless => Some("arpae_cosmo_seamless"),
      Self::arpae_cosmo_2i => Some("arpae_cosmo_2i"),
      Self::arpae_cosmo_2i_ruc => Some("arpae_cosmo_2i_ruc"),
      Self::arpae_cosmo_5m => Some("arpae_cosmo_5m"),
      Self::ecmwf_ifs025 => Some("ecmwf_ifs025"),
      Self::ecmwf_aifs025 => Some("ecmwf_aifs025"),
      Self::gfs013 => Some("gfs013"),
      Self::gfs_graphcast025 => Some("gfs_graphcast025"),
      Self::ecmwf_wam025 => Some("ecmwf_wam025"),
      Self::meteofrance_wave => Some("meteofrance_wave"),
      Self::meteofrance_currents => Some("meteofrance_currents"),
      Self::ecmwf_wam025_ensemble => Some("ecmwf_wam025_ensemble"),
      Self::ncep_gfswave025 => Some("ncep_gfswave025"),
      Self::ncep_gefswave025 => Some("ncep_gefswave025"),
      Self::knmi_seamless => Some("knmi_seamless"),
      Self::knmi_harmonie_arome_europe => Some("knmi_harmonie_arome_europe"),
      Self::knmi_harmonie_arome_netherlands => Some("knmi_harmonie_arome_netherlands"),
      Self::dmi_seamless => Some("dmi_seamless"),
      Self::dmi_harmonie_arome_europe => Some("dmi_harmonie_arome_europe"),
      Self::metno_seamless => Some("metno_seamless"),
      Self::era5_ensemble => Some("era5_ensemble"),
      Self::ecmwf_ifs_analysis => Some("ecmwf_ifs_analysis"),
      Self::ecmwf_ifs_long_window => Some("ecmwf_ifs_long_window"),
      Self::ecmwf_ifs_analysis_long_window => Some("ecmwf_ifs_analysis_long_window"),
      Self::ukmo_global_deterministic_10km => Some("ukmo_global_deterministic_10km"),
      Self::ukmo_uk_deterministic_2km => Some("ukmo_uk_deterministic_2km"),
      Self::ukmo_seamless => Some("ukmo_seamless"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Model {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Model {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Model {
    type Output = Model;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Model {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Model {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Model {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_VARIABLE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_VARIABLE: u8 = 111;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VARIABLE: [Variable; 112] = [
  Variable::undefined,
  Variable::apparent_temperature,
  Variable::cape,
  Variable::cloud_cover,
  Variable::cloud_cover_high,
  Variable::cloud_cover_low,
  Variable::cloud_cover_mid,
  Variable::daylight_duration,
  Variable::dew_point,
  Variable::diffuse_radiation,
  Variable::diffuse_radiation_instant,
  Variable::direct_normal_irradiance,
  Variable::direct_normal_irradiance_instant,
  Variable::direct_radiation,
  Variable::direct_radiation_instant,
  Variable::et0_fao_evapotranspiration,
  Variable::evapotranspiration,
  Variable::freezing_level_height,
  Variable::growing_degree_days,
  Variable::is_day,
  Variable::latent_heat_flux,
  Variable::leaf_wetness_probability,
  Variable::lifted_index,
  Variable::lightning_potential,
  Variable::precipitation,
  Variable::precipitation_hours,
  Variable::precipitation_probability,
  Variable::pressure_msl,
  Variable::rain,
  Variable::relative_humidity,
  Variable::runoff,
  Variable::sensible_heat_flux,
  Variable::shortwave_radiation,
  Variable::shortwave_radiation_instant,
  Variable::showers,
  Variable::snow_depth,
  Variable::snow_height,
  Variable::snowfall,
  Variable::snowfall_height,
  Variable::snowfall_water_equivalent,
  Variable::sunrise,
  Variable::sunset,
  Variable::soil_moisture,
  Variable::soil_moisture_index,
  Variable::soil_temperature,
  Variable::surface_pressure,
  Variable::surface_temperature,
  Variable::temperature,
  Variable::terrestrial_radiation,
  Variable::terrestrial_radiation_instant,
  Variable::total_column_integrated_water_vapour,
  Variable::updraft,
  Variable::uv_index,
  Variable::uv_index_clear_sky,
  Variable::vapour_pressure_deficit,
  Variable::visibility,
  Variable::weather_code,
  Variable::wind_direction,
  Variable::wind_gusts,
  Variable::wind_speed,
  Variable::vertical_velocity,
  Variable::geopotential_height,
  Variable::wet_bulb_temperature,
  Variable::river_discharge,
  Variable::wave_height,
  Variable::wave_period,
  Variable::wave_direction,
  Variable::wind_wave_height,
  Variable::wind_wave_period,
  Variable::wind_wave_peak_period,
  Variable::wind_wave_direction,
  Variable::swell_wave_height,
  Variable::swell_wave_period,
  Variable::swell_wave_peak_period,
  Variable::swell_wave_direction,
  Variable::pm10,
  Variable::pm2p5,
  Variable::dust,
  Variable::aerosol_optical_depth,
  Variable::carbon_monoxide,
  Variable::nitrogen_dioxide,
  Variable::ammonia,
  Variable::ozone,
  Variable::sulphur_dioxide,
  Variable::alder_pollen,
  Variable::birch_pollen,
  Variable::grass_pollen,
  Variable::mugwort_pollen,
  Variable::olive_pollen,
  Variable::ragweed_pollen,
  Variable::european_aqi,
  Variable::european_aqi_pm2p5,
  Variable::european_aqi_pm10,
  Variable::european_aqi_nitrogen_dioxide,
  Variable::european_aqi_ozone,
  Variable::european_aqi_sulphur_dioxide,
  Variable::us_aqi,
  Variable::us_aqi_pm2p5,
  Variable::us_aqi_pm10,
  Variable::us_aqi_nitrogen_dioxide,
  Variable::us_aqi_ozone,
  Variable::us_aqi_sulphur_dioxide,
  Variable::us_aqi_carbon_monoxide,
  Variable::sunshine_duration,
  Variable::convective_inhibition,
  Variable::shortwave_radiation_clear_sky,
  Variable::global_tilted_irradiance,
  Variable::global_tilted_irradiance_instant,
  Variable::ocean_current_velocity,
  Variable::ocean_current_direction,
  Variable::cloud_base,
  Variable::cloud_top,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Variable(pub u8);
#[allow(non_upper_case_globals)]
impl Variable {
  pub const undefined: Self = Self(0);
  pub const apparent_temperature: Self = Self(1);
  pub const cape: Self = Self(2);
  pub const cloud_cover: Self = Self(3);
  pub const cloud_cover_high: Self = Self(4);
  pub const cloud_cover_low: Self = Self(5);
  pub const cloud_cover_mid: Self = Self(6);
  pub const daylight_duration: Self = Self(7);
  pub const dew_point: Self = Self(8);
  pub const diffuse_radiation: Self = Self(9);
  pub const diffuse_radiation_instant: Self = Self(10);
  pub const direct_normal_irradiance: Self = Self(11);
  pub const direct_normal_irradiance_instant: Self = Self(12);
  pub const direct_radiation: Self = Self(13);
  pub const direct_radiation_instant: Self = Self(14);
  pub const et0_fao_evapotranspiration: Self = Self(15);
  pub const evapotranspiration: Self = Self(16);
  pub const freezing_level_height: Self = Self(17);
  pub const growing_degree_days: Self = Self(18);
  pub const is_day: Self = Self(19);
  pub const latent_heat_flux: Self = Self(20);
  pub const leaf_wetness_probability: Self = Self(21);
  pub const lifted_index: Self = Self(22);
  pub const lightning_potential: Self = Self(23);
  pub const precipitation: Self = Self(24);
  pub const precipitation_hours: Self = Self(25);
  pub const precipitation_probability: Self = Self(26);
  pub const pressure_msl: Self = Self(27);
  pub const rain: Self = Self(28);
  pub const relative_humidity: Self = Self(29);
  pub const runoff: Self = Self(30);
  pub const sensible_heat_flux: Self = Self(31);
  pub const shortwave_radiation: Self = Self(32);
  pub const shortwave_radiation_instant: Self = Self(33);
  pub const showers: Self = Self(34);
  pub const snow_depth: Self = Self(35);
  pub const snow_height: Self = Self(36);
  pub const snowfall: Self = Self(37);
  pub const snowfall_height: Self = Self(38);
  pub const snowfall_water_equivalent: Self = Self(39);
  pub const sunrise: Self = Self(40);
  pub const sunset: Self = Self(41);
  pub const soil_moisture: Self = Self(42);
  pub const soil_moisture_index: Self = Self(43);
  pub const soil_temperature: Self = Self(44);
  pub const surface_pressure: Self = Self(45);
  pub const surface_temperature: Self = Self(46);
  pub const temperature: Self = Self(47);
  pub const terrestrial_radiation: Self = Self(48);
  pub const terrestrial_radiation_instant: Self = Self(49);
  pub const total_column_integrated_water_vapour: Self = Self(50);
  pub const updraft: Self = Self(51);
  pub const uv_index: Self = Self(52);
  pub const uv_index_clear_sky: Self = Self(53);
  pub const vapour_pressure_deficit: Self = Self(54);
  pub const visibility: Self = Self(55);
  pub const weather_code: Self = Self(56);
  pub const wind_direction: Self = Self(57);
  pub const wind_gusts: Self = Self(58);
  pub const wind_speed: Self = Self(59);
  pub const vertical_velocity: Self = Self(60);
  pub const geopotential_height: Self = Self(61);
  pub const wet_bulb_temperature: Self = Self(62);
  pub const river_discharge: Self = Self(63);
  pub const wave_height: Self = Self(64);
  pub const wave_period: Self = Self(65);
  pub const wave_direction: Self = Self(66);
  pub const wind_wave_height: Self = Self(67);
  pub const wind_wave_period: Self = Self(68);
  pub const wind_wave_peak_period: Self = Self(69);
  pub const wind_wave_direction: Self = Self(70);
  pub const swell_wave_height: Self = Self(71);
  pub const swell_wave_period: Self = Self(72);
  pub const swell_wave_peak_period: Self = Self(73);
  pub const swell_wave_direction: Self = Self(74);
  pub const pm10: Self = Self(75);
  pub const pm2p5: Self = Self(76);
  pub const dust: Self = Self(77);
  pub const aerosol_optical_depth: Self = Self(78);
  pub const carbon_monoxide: Self = Self(79);
  pub const nitrogen_dioxide: Self = Self(80);
  pub const ammonia: Self = Self(81);
  pub const ozone: Self = Self(82);
  pub const sulphur_dioxide: Self = Self(83);
  pub const alder_pollen: Self = Self(84);
  pub const birch_pollen: Self = Self(85);
  pub const grass_pollen: Self = Self(86);
  pub const mugwort_pollen: Self = Self(87);
  pub const olive_pollen: Self = Self(88);
  pub const ragweed_pollen: Self = Self(89);
  pub const european_aqi: Self = Self(90);
  pub const european_aqi_pm2p5: Self = Self(91);
  pub const european_aqi_pm10: Self = Self(92);
  pub const european_aqi_nitrogen_dioxide: Self = Self(93);
  pub const european_aqi_ozone: Self = Self(94);
  pub const european_aqi_sulphur_dioxide: Self = Self(95);
  pub const us_aqi: Self = Self(96);
  pub const us_aqi_pm2p5: Self = Self(97);
  pub const us_aqi_pm10: Self = Self(98);
  pub const us_aqi_nitrogen_dioxide: Self = Self(99);
  pub const us_aqi_ozone: Self = Self(100);
  pub const us_aqi_sulphur_dioxide: Self = Self(101);
  pub const us_aqi_carbon_monoxide: Self = Self(102);
  pub const sunshine_duration: Self = Self(103);
  pub const convective_inhibition: Self = Self(104);
  pub const shortwave_radiation_clear_sky: Self = Self(105);
  pub const global_tilted_irradiance: Self = Self(106);
  pub const global_tilted_irradiance_instant: Self = Self(107);
  pub const ocean_current_velocity: Self = Self(108);
  pub const ocean_current_direction: Self = Self(109);
  pub const cloud_base: Self = Self(110);
  pub const cloud_top: Self = Self(111);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 111;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::undefined,
    Self::apparent_temperature,
    Self::cape,
    Self::cloud_cover,
    Self::cloud_cover_high,
    Self::cloud_cover_low,
    Self::cloud_cover_mid,
    Self::daylight_duration,
    Self::dew_point,
    Self::diffuse_radiation,
    Self::diffuse_radiation_instant,
    Self::direct_normal_irradiance,
    Self::direct_normal_irradiance_instant,
    Self::direct_radiation,
    Self::direct_radiation_instant,
    Self::et0_fao_evapotranspiration,
    Self::evapotranspiration,
    Self::freezing_level_height,
    Self::growing_degree_days,
    Self::is_day,
    Self::latent_heat_flux,
    Self::leaf_wetness_probability,
    Self::lifted_index,
    Self::lightning_potential,
    Self::precipitation,
    Self::precipitation_hours,
    Self::precipitation_probability,
    Self::pressure_msl,
    Self::rain,
    Self::relative_humidity,
    Self::runoff,
    Self::sensible_heat_flux,
    Self::shortwave_radiation,
    Self::shortwave_radiation_instant,
    Self::showers,
    Self::snow_depth,
    Self::snow_height,
    Self::snowfall,
    Self::snowfall_height,
    Self::snowfall_water_equivalent,
    Self::sunrise,
    Self::sunset,
    Self::soil_moisture,
    Self::soil_moisture_index,
    Self::soil_temperature,
    Self::surface_pressure,
    Self::surface_temperature,
    Self::temperature,
    Self::terrestrial_radiation,
    Self::terrestrial_radiation_instant,
    Self::total_column_integrated_water_vapour,
    Self::updraft,
    Self::uv_index,
    Self::uv_index_clear_sky,
    Self::vapour_pressure_deficit,
    Self::visibility,
    Self::weather_code,
    Self::wind_direction,
    Self::wind_gusts,
    Self::wind_speed,
    Self::vertical_velocity,
    Self::geopotential_height,
    Self::wet_bulb_temperature,
    Self::river_discharge,
    Self::wave_height,
    Self::wave_period,
    Self::wave_direction,
    Self::wind_wave_height,
    Self::wind_wave_period,
    Self::wind_wave_peak_period,
    Self::wind_wave_direction,
    Self::swell_wave_height,
    Self::swell_wave_period,
    Self::swell_wave_peak_period,
    Self::swell_wave_direction,
    Self::pm10,
    Self::pm2p5,
    Self::dust,
    Self::aerosol_optical_depth,
    Self::carbon_monoxide,
    Self::nitrogen_dioxide,
    Self::ammonia,
    Self::ozone,
    Self::sulphur_dioxide,
    Self::alder_pollen,
    Self::birch_pollen,
    Self::grass_pollen,
    Self::mugwort_pollen,
    Self::olive_pollen,
    Self::ragweed_pollen,
    Self::european_aqi,
    Self::european_aqi_pm2p5,
    Self::european_aqi_pm10,
    Self::european_aqi_nitrogen_dioxide,
    Self::european_aqi_ozone,
    Self::european_aqi_sulphur_dioxide,
    Self::us_aqi,
    Self::us_aqi_pm2p5,
    Self::us_aqi_pm10,
    Self::us_aqi_nitrogen_dioxide,
    Self::us_aqi_ozone,
    Self::us_aqi_sulphur_dioxide,
    Self::us_aqi_carbon_monoxide,
    Self::sunshine_duration,
    Self::convective_inhibition,
    Self::shortwave_radiation_clear_sky,
    Self::global_tilted_irradiance,
    Self::global_tilted_irradiance_instant,
    Self::ocean_current_velocity,
    Self::ocean_current_direction,
    Self::cloud_base,
    Self::cloud_top,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::undefined => Some("undefined"),
      Self::apparent_temperature => Some("apparent_temperature"),
      Self::cape => Some("cape"),
      Self::cloud_cover => Some("cloud_cover"),
      Self::cloud_cover_high => Some("cloud_cover_high"),
      Self::cloud_cover_low => Some("cloud_cover_low"),
      Self::cloud_cover_mid => Some("cloud_cover_mid"),
      Self::daylight_duration => Some("daylight_duration"),
      Self::dew_point => Some("dew_point"),
      Self::diffuse_radiation => Some("diffuse_radiation"),
      Self::diffuse_radiation_instant => Some("diffuse_radiation_instant"),
      Self::direct_normal_irradiance => Some("direct_normal_irradiance"),
      Self::direct_normal_irradiance_instant => Some("direct_normal_irradiance_instant"),
      Self::direct_radiation => Some("direct_radiation"),
      Self::direct_radiation_instant => Some("direct_radiation_instant"),
      Self::et0_fao_evapotranspiration => Some("et0_fao_evapotranspiration"),
      Self::evapotranspiration => Some("evapotranspiration"),
      Self::freezing_level_height => Some("freezing_level_height"),
      Self::growing_degree_days => Some("growing_degree_days"),
      Self::is_day => Some("is_day"),
      Self::latent_heat_flux => Some("latent_heat_flux"),
      Self::leaf_wetness_probability => Some("leaf_wetness_probability"),
      Self::lifted_index => Some("lifted_index"),
      Self::lightning_potential => Some("lightning_potential"),
      Self::precipitation => Some("precipitation"),
      Self::precipitation_hours => Some("precipitation_hours"),
      Self::precipitation_probability => Some("precipitation_probability"),
      Self::pressure_msl => Some("pressure_msl"),
      Self::rain => Some("rain"),
      Self::relative_humidity => Some("relative_humidity"),
      Self::runoff => Some("runoff"),
      Self::sensible_heat_flux => Some("sensible_heat_flux"),
      Self::shortwave_radiation => Some("shortwave_radiation"),
      Self::shortwave_radiation_instant => Some("shortwave_radiation_instant"),
      Self::showers => Some("showers"),
      Self::snow_depth => Some("snow_depth"),
      Self::snow_height => Some("snow_height"),
      Self::snowfall => Some("snowfall"),
      Self::snowfall_height => Some("snowfall_height"),
      Self::snowfall_water_equivalent => Some("snowfall_water_equivalent"),
      Self::sunrise => Some("sunrise"),
      Self::sunset => Some("sunset"),
      Self::soil_moisture => Some("soil_moisture"),
      Self::soil_moisture_index => Some("soil_moisture_index"),
      Self::soil_temperature => Some("soil_temperature"),
      Self::surface_pressure => Some("surface_pressure"),
      Self::surface_temperature => Some("surface_temperature"),
      Self::temperature => Some("temperature"),
      Self::terrestrial_radiation => Some("terrestrial_radiation"),
      Self::terrestrial_radiation_instant => Some("terrestrial_radiation_instant"),
      Self::total_column_integrated_water_vapour => Some("total_column_integrated_water_vapour"),
      Self::updraft => Some("updraft"),
      Self::uv_index => Some("uv_index"),
      Self::uv_index_clear_sky => Some("uv_index_clear_sky"),
      Self::vapour_pressure_deficit => Some("vapour_pressure_deficit"),
      Self::visibility => Some("visibility"),
      Self::weather_code => Some("weather_code"),
      Self::wind_direction => Some("wind_direction"),
      Self::wind_gusts => Some("wind_gusts"),
      Self::wind_speed => Some("wind_speed"),
      Self::vertical_velocity => Some("vertical_velocity"),
      Self::geopotential_height => Some("geopotential_height"),
      Self::wet_bulb_temperature => Some("wet_bulb_temperature"),
      Self::river_discharge => Some("river_discharge"),
      Self::wave_height => Some("wave_height"),
      Self::wave_period => Some("wave_period"),
      Self::wave_direction => Some("wave_direction"),
      Self::wind_wave_height => Some("wind_wave_height"),
      Self::wind_wave_period => Some("wind_wave_period"),
      Self::wind_wave_peak_period => Some("wind_wave_peak_period"),
      Self::wind_wave_direction => Some("wind_wave_direction"),
      Self::swell_wave_height => Some("swell_wave_height"),
      Self::swell_wave_period => Some("swell_wave_period"),
      Self::swell_wave_peak_period => Some("swell_wave_peak_period"),
      Self::swell_wave_direction => Some("swell_wave_direction"),
      Self::pm10 => Some("pm10"),
      Self::pm2p5 => Some("pm2p5"),
      Self::dust => Some("dust"),
      Self::aerosol_optical_depth => Some("aerosol_optical_depth"),
      Self::carbon_monoxide => Some("carbon_monoxide"),
      Self::nitrogen_dioxide => Some("nitrogen_dioxide"),
      Self::ammonia => Some("ammonia"),
      Self::ozone => Some("ozone"),
      Self::sulphur_dioxide => Some("sulphur_dioxide"),
      Self::alder_pollen => Some("alder_pollen"),
      Self::birch_pollen => Some("birch_pollen"),
      Self::grass_pollen => Some("grass_pollen"),
      Self::mugwort_pollen => Some("mugwort_pollen"),
      Self::olive_pollen => Some("olive_pollen"),
      Self::ragweed_pollen => Some("ragweed_pollen"),
      Self::european_aqi => Some("european_aqi"),
      Self::european_aqi_pm2p5 => Some("european_aqi_pm2p5"),
      Self::european_aqi_pm10 => Some("european_aqi_pm10"),
      Self::european_aqi_nitrogen_dioxide => Some("european_aqi_nitrogen_dioxide"),
      Self::european_aqi_ozone => Some("european_aqi_ozone"),
      Self::european_aqi_sulphur_dioxide => Some("european_aqi_sulphur_dioxide"),
      Self::us_aqi => Some("us_aqi"),
      Self::us_aqi_pm2p5 => Some("us_aqi_pm2p5"),
      Self::us_aqi_pm10 => Some("us_aqi_pm10"),
      Self::us_aqi_nitrogen_dioxide => Some("us_aqi_nitrogen_dioxide"),
      Self::us_aqi_ozone => Some("us_aqi_ozone"),
      Self::us_aqi_sulphur_dioxide => Some("us_aqi_sulphur_dioxide"),
      Self::us_aqi_carbon_monoxide => Some("us_aqi_carbon_monoxide"),
      Self::sunshine_duration => Some("sunshine_duration"),
      Self::convective_inhibition => Some("convective_inhibition"),
      Self::shortwave_radiation_clear_sky => Some("shortwave_radiation_clear_sky"),
      Self::global_tilted_irradiance => Some("global_tilted_irradiance"),
      Self::global_tilted_irradiance_instant => Some("global_tilted_irradiance_instant"),
      Self::ocean_current_velocity => Some("ocean_current_velocity"),
      Self::ocean_current_direction => Some("ocean_current_direction"),
      Self::cloud_base => Some("cloud_base"),
      Self::cloud_top => Some("cloud_top"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Variable {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Variable {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Variable {
    type Output = Variable;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Variable {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Variable {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Variable {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_AGGREGATION: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_AGGREGATION: u8 = 11;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_AGGREGATION: [Aggregation; 12] = [
  Aggregation::none,
  Aggregation::minimum,
  Aggregation::maximum,
  Aggregation::mean,
  Aggregation::p10,
  Aggregation::p25,
  Aggregation::median,
  Aggregation::p75,
  Aggregation::p90,
  Aggregation::dominant,
  Aggregation::sum,
  Aggregation::spread,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Aggregation(pub u8);
#[allow(non_upper_case_globals)]
impl Aggregation {
  pub const none: Self = Self(0);
  pub const minimum: Self = Self(1);
  pub const maximum: Self = Self(2);
  pub const mean: Self = Self(3);
  pub const p10: Self = Self(4);
  pub const p25: Self = Self(5);
  pub const median: Self = Self(6);
  pub const p75: Self = Self(7);
  pub const p90: Self = Self(8);
  pub const dominant: Self = Self(9);
  pub const sum: Self = Self(10);
  pub const spread: Self = Self(11);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 11;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::none,
    Self::minimum,
    Self::maximum,
    Self::mean,
    Self::p10,
    Self::p25,
    Self::median,
    Self::p75,
    Self::p90,
    Self::dominant,
    Self::sum,
    Self::spread,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::none => Some("none"),
      Self::minimum => Some("minimum"),
      Self::maximum => Some("maximum"),
      Self::mean => Some("mean"),
      Self::p10 => Some("p10"),
      Self::p25 => Some("p25"),
      Self::median => Some("median"),
      Self::p75 => Some("p75"),
      Self::p90 => Some("p90"),
      Self::dominant => Some("dominant"),
      Self::sum => Some("sum"),
      Self::spread => Some("spread"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Aggregation {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Aggregation {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Aggregation {
    type Output = Aggregation;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Aggregation {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Aggregation {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Aggregation {}
pub enum VariableWithValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VariableWithValues<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariableWithValues<'a> {
  type Inner = VariableWithValues<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VariableWithValues<'a> {
  pub const VT_VARIABLE: flatbuffers::VOffsetT = 4;
  pub const VT_UNIT: flatbuffers::VOffsetT = 6;
  pub const VT_VALUE: flatbuffers::VOffsetT = 8;
  pub const VT_VALUES: flatbuffers::VOffsetT = 10;
  pub const VT_VALUES_INT64: flatbuffers::VOffsetT = 12;
  pub const VT_ALTITUDE: flatbuffers::VOffsetT = 14;
  pub const VT_AGGREGATION: flatbuffers::VOffsetT = 16;
  pub const VT_PRESSURE_LEVEL: flatbuffers::VOffsetT = 18;
  pub const VT_DEPTH: flatbuffers::VOffsetT = 20;
  pub const VT_DEPTH_TO: flatbuffers::VOffsetT = 22;
  pub const VT_ENSEMBLE_MEMBER: flatbuffers::VOffsetT = 24;
  pub const VT_PREVIOUS_DAY: flatbuffers::VOffsetT = 26;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VariableWithValues { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VariableWithValuesArgs<'args>
  ) -> flatbuffers::WIPOffset<VariableWithValues<'bldr>> {
    let mut builder = VariableWithValuesBuilder::new(_fbb);
    if let Some(x) = args.values_int64 { builder.add_values_int64(x); }
    if let Some(x) = args.values { builder.add_values(x); }
    builder.add_value(args.value);
    builder.add_previous_day(args.previous_day);
    builder.add_ensemble_member(args.ensemble_member);
    builder.add_depth_to(args.depth_to);
    builder.add_depth(args.depth);
    builder.add_pressure_level(args.pressure_level);
    builder.add_altitude(args.altitude);
    builder.add_aggregation(args.aggregation);
    builder.add_unit(args.unit);
    builder.add_variable(args.variable);
    builder.finish()
  }


  #[inline]
  pub fn variable(&self) -> Variable {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Variable>(VariableWithValues::VT_VARIABLE, Some(Variable::undefined)).unwrap()}
  }
  #[inline]
  pub fn unit(&self) -> Unit {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Unit>(VariableWithValues::VT_UNIT, Some(Unit::undefined)).unwrap()}
  }
  #[inline]
  pub fn value(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(VariableWithValues::VT_VALUE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn values(&self) -> Option<flatbuffers::Vector<'a, f32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(VariableWithValues::VT_VALUES, None)}
  }
  #[inline]
  pub fn values_int64(&self) -> Option<flatbuffers::Vector<'a, i64>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(VariableWithValues::VT_VALUES_INT64, None)}
  }
  #[inline]
  pub fn altitude(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_ALTITUDE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn aggregation(&self) -> Aggregation {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Aggregation>(VariableWithValues::VT_AGGREGATION, Some(Aggregation::none)).unwrap()}
  }
  #[inline]
  pub fn pressure_level(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_PRESSURE_LEVEL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn depth(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_DEPTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn depth_to(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_DEPTH_TO, Some(0)).unwrap()}
  }
  #[inline]
  pub fn ensemble_member(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_ENSEMBLE_MEMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn previous_day(&self) -> i16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i16>(VariableWithValues::VT_PREVIOUS_DAY, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for VariableWithValues<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Variable>("variable", Self::VT_VARIABLE, false)?
     .visit_field::<Unit>("unit", Self::VT_UNIT, false)?
     .visit_field::<f32>("value", Self::VT_VALUE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>("values", Self::VT_VALUES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>("values_int64", Self::VT_VALUES_INT64, false)?
     .visit_field::<i16>("altitude", Self::VT_ALTITUDE, false)?
     .visit_field::<Aggregation>("aggregation", Self::VT_AGGREGATION, false)?
     .visit_field::<i16>("pressure_level", Self::VT_PRESSURE_LEVEL, false)?
     .visit_field::<i16>("depth", Self::VT_DEPTH, false)?
     .visit_field::<i16>("depth_to", Self::VT_DEPTH_TO, false)?
     .visit_field::<i16>("ensemble_member", Self::VT_ENSEMBLE_MEMBER, false)?
     .visit_field::<i16>("previous_day", Self::VT_PREVIOUS_DAY, false)?
     .finish();
    Ok(())
  }
}
pub struct VariableWithValuesArgs<'a> {
    pub variable: Variable,
    pub unit: Unit,
    pub value: f32,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
    pub values_int64: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
    pub altitude: i16,
    pub aggregation: Aggregation,
    pub pressure_level: i16,
    pub depth: i16,
    pub depth_to: i16,
    pub ensemble_member: i16,
    pub previous_day: i16,
}
impl<'a> Default for VariableWithValuesArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariableWithValuesArgs {
      variable: Variable::undefined,
      unit: Unit::undefined,
      value: 0.0,
      values: None,
      values_int64: None,
      altitude: 0,
      aggregation: Aggregation::none,
      pressure_level: 0,
      depth: 0,
      depth_to: 0,
      ensemble_member: 0,
      previous_day: 0,
    }
  }
}

pub struct VariableWithValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VariableWithValuesBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_variable(&mut self, variable: Variable) {
    self.fbb_.push_slot::<Variable>(VariableWithValues::VT_VARIABLE, variable, Variable::undefined);
  }
  #[inline]
  pub fn add_unit(&mut self, unit: Unit) {
    self.fbb_.push_slot::<Unit>(VariableWithValues::VT_UNIT, unit, Unit::undefined);
  }
  #[inline]
  pub fn add_value(&mut self, value: f32) {
    self.fbb_.push_slot::<f32>(VariableWithValues::VT_VALUE, value, 0.0);
  }
  #[inline]
  pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b , f32>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableWithValues::VT_VALUES, values);
  }
  #[inline]
  pub fn add_values_int64(&mut self, values_int64: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariableWithValues::VT_VALUES_INT64, values_int64);
  }
  #[inline]
  pub fn add_altitude(&mut self, altitude: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_ALTITUDE, altitude, 0);
  }
  #[inline]
  pub fn add_aggregation(&mut self, aggregation: Aggregation) {
    self.fbb_.push_slot::<Aggregation>(VariableWithValues::VT_AGGREGATION, aggregation, Aggregation::none);
  }
  #[inline]
  pub fn add_pressure_level(&mut self, pressure_level: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_PRESSURE_LEVEL, pressure_level, 0);
  }
  #[inline]
  pub fn add_depth(&mut self, depth: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_DEPTH, depth, 0);
  }
  #[inline]
  pub fn add_depth_to(&mut self, depth_to: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_DEPTH_TO, depth_to, 0);
  }
  #[inline]
  pub fn add_ensemble_member(&mut self, ensemble_member: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_ENSEMBLE_MEMBER, ensemble_member, 0);
  }
  #[inline]
  pub fn add_previous_day(&mut self, previous_day: i16) {
    self.fbb_.push_slot::<i16>(VariableWithValues::VT_PREVIOUS_DAY, previous_day, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VariableWithValuesBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VariableWithValuesBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariableWithValues<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VariableWithValues<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VariableWithValues");
      ds.field("variable", &self.variable());
      ds.field("unit", &self.unit());
      ds.field("value", &self.value());
      ds.field("values", &self.values());
      ds.field("values_int64", &self.values_int64());
      ds.field("altitude", &self.altitude());
      ds.field("aggregation", &self.aggregation());
      ds.field("pressure_level", &self.pressure_level());
      ds.field("depth", &self.depth());
      ds.field("depth_to", &self.depth_to());
      ds.field("ensemble_member", &self.ensemble_member());
      ds.field("previous_day", &self.previous_day());
      ds.finish()
  }
}
pub enum VariablesWithTimeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct VariablesWithTime<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for VariablesWithTime<'a> {
  type Inner = VariablesWithTime<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> VariablesWithTime<'a> {
  pub const VT_TIME: flatbuffers::VOffsetT = 4;
  pub const VT_TIME_END: flatbuffers::VOffsetT = 6;
  pub const VT_INTERVAL: flatbuffers::VOffsetT = 8;
  pub const VT_VARIABLES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    VariablesWithTime { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args VariablesWithTimeArgs<'args>
  ) -> flatbuffers::WIPOffset<VariablesWithTime<'bldr>> {
    let mut builder = VariablesWithTimeBuilder::new(_fbb);
    builder.add_time_end(args.time_end);
    builder.add_time(args.time);
    if let Some(x) = args.variables { builder.add_variables(x); }
    builder.add_interval(args.interval);
    builder.finish()
  }


  #[inline]
  pub fn time(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(VariablesWithTime::VT_TIME, Some(0)).unwrap()}
  }
  #[inline]
  pub fn time_end(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(VariablesWithTime::VT_TIME_END, Some(0)).unwrap()}
  }
  #[inline]
  pub fn interval(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(VariablesWithTime::VT_INTERVAL, Some(0)).unwrap()}
  }
  #[inline]
  pub fn variables(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableWithValues<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableWithValues>>>>(VariablesWithTime::VT_VARIABLES, None)}
  }
}

impl flatbuffers::Verifiable for VariablesWithTime<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<i64>("time", Self::VT_TIME, false)?
     .visit_field::<i64>("time_end", Self::VT_TIME_END, false)?
     .visit_field::<i32>("interval", Self::VT_INTERVAL, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<VariableWithValues>>>>("variables", Self::VT_VARIABLES, false)?
     .finish();
    Ok(())
  }
}
pub struct VariablesWithTimeArgs<'a> {
    pub time: i64,
    pub time_end: i64,
    pub interval: i32,
    pub variables: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<VariableWithValues<'a>>>>>,
}
impl<'a> Default for VariablesWithTimeArgs<'a> {
  #[inline]
  fn default() -> Self {
    VariablesWithTimeArgs {
      time: 0,
      time_end: 0,
      interval: 0,
      variables: None,
    }
  }
}

pub struct VariablesWithTimeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> VariablesWithTimeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_time(&mut self, time: i64) {
    self.fbb_.push_slot::<i64>(VariablesWithTime::VT_TIME, time, 0);
  }
  #[inline]
  pub fn add_time_end(&mut self, time_end: i64) {
    self.fbb_.push_slot::<i64>(VariablesWithTime::VT_TIME_END, time_end, 0);
  }
  #[inline]
  pub fn add_interval(&mut self, interval: i32) {
    self.fbb_.push_slot::<i32>(VariablesWithTime::VT_INTERVAL, interval, 0);
  }
  #[inline]
  pub fn add_variables(&mut self, variables: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<VariableWithValues<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(VariablesWithTime::VT_VARIABLES, variables);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> VariablesWithTimeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    VariablesWithTimeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<VariablesWithTime<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for VariablesWithTime<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("VariablesWithTime");
      ds.field("time", &self.time());
      ds.field("time_end", &self.time_end());
      ds.field("interval", &self.interval());
      ds.field("variables", &self.variables());
      ds.finish()
  }
}
pub enum WeatherApiResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct WeatherApiResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for WeatherApiResponse<'a> {
  type Inner = WeatherApiResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> WeatherApiResponse<'a> {
  pub const VT_LATITUDE: flatbuffers::VOffsetT = 4;
  pub const VT_LONGITUDE: flatbuffers::VOffsetT = 6;
  pub const VT_ELEVATION: flatbuffers::VOffsetT = 8;
  pub const VT_GENERATION_TIME_MILLISECONDS: flatbuffers::VOffsetT = 10;
  pub const VT_LOCATION_ID: flatbuffers::VOffsetT = 12;
  pub const VT_MODEL: flatbuffers::VOffsetT = 14;
  pub const VT_UTC_OFFSET_SECONDS: flatbuffers::VOffsetT = 16;
  pub const VT_TIMEZONE: flatbuffers::VOffsetT = 18;
  pub const VT_TIMEZONE_ABBREVIATION: flatbuffers::VOffsetT = 20;
  pub const VT_CURRENT: flatbuffers::VOffsetT = 22;
  pub const VT_DAILY: flatbuffers::VOffsetT = 24;
  pub const VT_HOURLY: flatbuffers::VOffsetT = 26;
  pub const VT_MINUTELY_15: flatbuffers::VOffsetT = 28;
  pub const VT_SIX_HOURLY: flatbuffers::VOffsetT = 30;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    WeatherApiResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args WeatherApiResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<WeatherApiResponse<'bldr>> {
    let mut builder = WeatherApiResponseBuilder::new(_fbb);
    builder.add_location_id(args.location_id);
    if let Some(x) = args.six_hourly { builder.add_six_hourly(x); }
    if let Some(x) = args.minutely_15 { builder.add_minutely_15(x); }
    if let Some(x) = args.hourly { builder.add_hourly(x); }
    if let Some(x) = args.daily { builder.add_daily(x); }
    if let Some(x) = args.current { builder.add_current(x); }
    if let Some(x) = args.timezone_abbreviation { builder.add_timezone_abbreviation(x); }
    if let Some(x) = args.timezone { builder.add_timezone(x); }
    builder.add_utc_offset_seconds(args.utc_offset_seconds);
    builder.add_generation_time_milliseconds(args.generation_time_milliseconds);
    builder.add_elevation(args.elevation);
    builder.add_longitude(args.longitude);
    builder.add_latitude(args.latitude);
    builder.add_model(args.model);
    builder.finish()
  }


  #[inline]
  pub fn latitude(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WeatherApiResponse::VT_LATITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn longitude(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WeatherApiResponse::VT_LONGITUDE, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn elevation(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WeatherApiResponse::VT_ELEVATION, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn generation_time_milliseconds(&self) -> f32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<f32>(WeatherApiResponse::VT_GENERATION_TIME_MILLISECONDS, Some(0.0)).unwrap()}
  }
  #[inline]
  pub fn location_id(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(WeatherApiResponse::VT_LOCATION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn model(&self) -> Model {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Model>(WeatherApiResponse::VT_MODEL, Some(Model::undefined)).unwrap()}
  }
  #[inline]
  pub fn utc_offset_seconds(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(WeatherApiResponse::VT_UTC_OFFSET_SECONDS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timezone(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherApiResponse::VT_TIMEZONE, None)}
  }
  #[inline]
  pub fn timezone_abbreviation(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(WeatherApiResponse::VT_TIMEZONE_ABBREVIATION, None)}
  }
  #[inline]
  pub fn current(&self) -> Option<VariablesWithTime<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VariablesWithTime>>(WeatherApiResponse::VT_CURRENT, None)}
  }
  #[inline]
  pub fn daily(&self) -> Option<VariablesWithTime<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VariablesWithTime>>(WeatherApiResponse::VT_DAILY, None)}
  }
  #[inline]
  pub fn hourly(&self) -> Option<VariablesWithTime<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VariablesWithTime>>(WeatherApiResponse::VT_HOURLY, None)}
  }
  #[inline]
  pub fn minutely_15(&self) -> Option<VariablesWithTime<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VariablesWithTime>>(WeatherApiResponse::VT_MINUTELY_15, None)}
  }
  #[inline]
  pub fn six_hourly(&self) -> Option<VariablesWithTime<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<VariablesWithTime>>(WeatherApiResponse::VT_SIX_HOURLY, None)}
  }
}

impl flatbuffers::Verifiable for WeatherApiResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<f32>("latitude", Self::VT_LATITUDE, false)?
     .visit_field::<f32>("longitude", Self::VT_LONGITUDE, false)?
     .visit_field::<f32>("elevation", Self::VT_ELEVATION, false)?
     .visit_field::<f32>("generation_time_milliseconds", Self::VT_GENERATION_TIME_MILLISECONDS, false)?
     .visit_field::<i64>("location_id", Self::VT_LOCATION_ID, false)?
     .visit_field::<Model>("model", Self::VT_MODEL, false)?
     .visit_field::<i32>("utc_offset_seconds", Self::VT_UTC_OFFSET_SECONDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("timezone", Self::VT_TIMEZONE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("timezone_abbreviation", Self::VT_TIMEZONE_ABBREVIATION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VariablesWithTime>>("current", Self::VT_CURRENT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VariablesWithTime>>("daily", Self::VT_DAILY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VariablesWithTime>>("hourly", Self::VT_HOURLY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VariablesWithTime>>("minutely_15", Self::VT_MINUTELY_15, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<VariablesWithTime>>("six_hourly", Self::VT_SIX_HOURLY, false)?
     .finish();
    Ok(())
  }
}
pub struct WeatherApiResponseArgs<'a> {
    pub latitude: f32,
    pub longitude: f32,
    pub elevation: f32,
    pub generation_time_milliseconds: f32,
    pub location_id: i64,
    pub model: Model,
    pub utc_offset_seconds: i32,
    pub timezone: Option<flatbuffers::WIPOffset<&'a str>>,
    pub timezone_abbreviation: Option<flatbuffers::WIPOffset<&'a str>>,
    pub current: Option<flatbuffers::WIPOffset<VariablesWithTime<'a>>>,
    pub daily: Option<flatbuffers::WIPOffset<VariablesWithTime<'a>>>,
    pub hourly: Option<flatbuffers::WIPOffset<VariablesWithTime<'a>>>,
    pub minutely_15: Option<flatbuffers::WIPOffset<VariablesWithTime<'a>>>,
    pub six_hourly: Option<flatbuffers::WIPOffset<VariablesWithTime<'a>>>,
}
impl<'a> Default for WeatherApiResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    WeatherApiResponseArgs {
      latitude: 0.0,
      longitude: 0.0,
      elevation: 0.0,
      generation_time_milliseconds: 0.0,
      location_id: 0,
      model: Model::undefined,
      utc_offset_seconds: 0,
      timezone: None,
      timezone_abbreviation: None,
      current: None,
      daily: None,
      hourly: None,
      minutely_15: None,
      six_hourly: None,
    }
  }
}

pub struct WeatherApiResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> WeatherApiResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_latitude(&mut self, latitude: f32) {
    self.fbb_.push_slot::<f32>(WeatherApiResponse::VT_LATITUDE, latitude, 0.0);
  }
  #[inline]
  pub fn add_longitude(&mut self, longitude: f32) {
    self.fbb_.push_slot::<f32>(WeatherApiResponse::VT_LONGITUDE, longitude, 0.0);
  }
  #[inline]
  pub fn add_elevation(&mut self, elevation: f32) {
    self.fbb_.push_slot::<f32>(WeatherApiResponse::VT_ELEVATION, elevation, 0.0);
  }
  #[inline]
  pub fn add_generation_time_milliseconds(&mut self, generation_time_milliseconds: f32) {
    self.fbb_.push_slot::<f32>(WeatherApiResponse::VT_GENERATION_TIME_MILLISECONDS, generation_time_milliseconds, 0.0);
  }
  #[inline]
  pub fn add_location_id(&mut self, location_id: i64) {
    self.fbb_.push_slot::<i64>(WeatherApiResponse::VT_LOCATION_ID, location_id, 0);
  }
  #[inline]
  pub fn add_model(&mut self, model: Model) {
    self.fbb_.push_slot::<Model>(WeatherApiResponse::VT_MODEL, model, Model::undefined);
  }
  #[inline]
  pub fn add_utc_offset_seconds(&mut self, utc_offset_seconds: i32) {
    self.fbb_.push_slot::<i32>(WeatherApiResponse::VT_UTC_OFFSET_SECONDS, utc_offset_seconds, 0);
  }
  #[inline]
  pub fn add_timezone(&mut self, timezone: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherApiResponse::VT_TIMEZONE, timezone);
  }
  #[inline]
  pub fn add_timezone_abbreviation(&mut self, timezone_abbreviation: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(WeatherApiResponse::VT_TIMEZONE_ABBREVIATION, timezone_abbreviation);
  }
  #[inline]
  pub fn add_current(&mut self, current: flatbuffers::WIPOffset<VariablesWithTime<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariablesWithTime>>(WeatherApiResponse::VT_CURRENT, current);
  }
  #[inline]
  pub fn add_daily(&mut self, daily: flatbuffers::WIPOffset<VariablesWithTime<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariablesWithTime>>(WeatherApiResponse::VT_DAILY, daily);
  }
  #[inline]
  pub fn add_hourly(&mut self, hourly: flatbuffers::WIPOffset<VariablesWithTime<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariablesWithTime>>(WeatherApiResponse::VT_HOURLY, hourly);
  }
  #[inline]
  pub fn add_minutely_15(&mut self, minutely_15: flatbuffers::WIPOffset<VariablesWithTime<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariablesWithTime>>(WeatherApiResponse::VT_MINUTELY_15, minutely_15);
  }
  #[inline]
  pub fn add_six_hourly(&mut self, six_hourly: flatbuffers::WIPOffset<VariablesWithTime<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<VariablesWithTime>>(WeatherApiResponse::VT_SIX_HOURLY, six_hourly);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> WeatherApiResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    WeatherApiResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<WeatherApiResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for WeatherApiResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("WeatherApiResponse");
      ds.field("latitude", &self.latitude());
      ds.field("longitude", &self.longitude());
      ds.field("elevation", &self.elevation());
      ds.field("generation_time_milliseconds", &self.generation_time_milliseconds());
      ds.field("location_id", &self.location_id());
      ds.field("model", &self.model());
      ds.field("utc_offset_seconds", &self.utc_offset_seconds());
      ds.field("timezone", &self.timezone());
      ds.field("timezone_abbreviation", &self.timezone_abbreviation());
      ds.field("current", &self.current());
      ds.field("daily", &self.daily());
      ds.field("hourly", &self.hourly());
      ds.field("minutely_15", &self.minutely_15());
      ds.field("six_hourly", &self.six_hourly());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `WeatherApiResponse`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_api_response_unchecked`.
pub fn root_as_weather_api_response(buf: &[u8]) -> Result<WeatherApiResponse, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<WeatherApiResponse>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `WeatherApiResponse` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_weather_api_response_unchecked`.
pub fn size_prefixed_root_as_weather_api_response(buf: &[u8]) -> Result<WeatherApiResponse, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<WeatherApiResponse>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `WeatherApiResponse` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_api_response_unchecked`.
pub fn root_as_weather_api_response_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WeatherApiResponse<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<WeatherApiResponse<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `WeatherApiResponse` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_weather_api_response_unchecked`.
pub fn size_prefixed_root_as_weather_api_response_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<WeatherApiResponse<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<WeatherApiResponse<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a WeatherApiResponse and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `WeatherApiResponse`.
pub unsafe fn root_as_weather_api_response_unchecked(buf: &[u8]) -> WeatherApiResponse {
  flatbuffers::root_unchecked::<WeatherApiResponse>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed WeatherApiResponse and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `WeatherApiResponse`.
pub unsafe fn size_prefixed_root_as_weather_api_response_unchecked(buf: &[u8]) -> WeatherApiResponse {
  flatbuffers::size_prefixed_root_unchecked::<WeatherApiResponse>(buf)
}
#[inline]
pub fn finish_weather_api_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<WeatherApiResponse<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_weather_api_response_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<WeatherApiResponse<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod openmeteo_sdk


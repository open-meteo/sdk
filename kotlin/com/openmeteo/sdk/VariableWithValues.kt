// automatically generated by the FlatBuffers compiler, do not modify

package com.openmeteo.sdk

import com.google.flatbuffers.BaseVector
import com.google.flatbuffers.BooleanVector
import com.google.flatbuffers.ByteVector
import com.google.flatbuffers.Constants
import com.google.flatbuffers.DoubleVector
import com.google.flatbuffers.FlatBufferBuilder
import com.google.flatbuffers.FloatVector
import com.google.flatbuffers.LongVector
import com.google.flatbuffers.StringVector
import com.google.flatbuffers.Struct
import com.google.flatbuffers.Table
import com.google.flatbuffers.UnionVector
import java.nio.ByteBuffer
import java.nio.ByteOrder
import kotlin.math.sign

@Suppress("unused")
class VariableWithValues : Table() {

    fun __init(_i: Int, _bb: ByteBuffer)  {
        __reset(_i, _bb)
    }
    fun __assign(_i: Int, _bb: ByteBuffer) : VariableWithValues {
        __init(_i, _bb)
        return this
    }
    val variable : UByte
        get() {
            val o = __offset(4)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val unit : UByte
        get() {
            val o = __offset(6)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val value : Float
        get() {
            val o = __offset(8)
            return if(o != 0) bb.getFloat(o + bb_pos) else 0.0f
        }
    fun values(j: Int) : Float {
        val o = __offset(10)
        return if (o != 0) {
            bb.getFloat(__vector(o) + j * 4)
        } else {
            0.0f
        }
    }
    val valuesLength : Int
        get() {
            val o = __offset(10); return if (o != 0) __vector_len(o) else 0
        }
    val valuesAsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(10, 4)
    fun valuesInByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 10, 4)
    fun valuesInt64(j: Int) : Long {
        val o = __offset(12)
        return if (o != 0) {
            bb.getLong(__vector(o) + j * 8)
        } else {
            0
        }
    }
    val valuesInt64Length : Int
        get() {
            val o = __offset(12); return if (o != 0) __vector_len(o) else 0
        }
    val valuesInt64AsByteBuffer : ByteBuffer get() = __vector_as_bytebuffer(12, 8)
    fun valuesInt64InByteBuffer(_bb: ByteBuffer) : ByteBuffer = __vector_in_bytebuffer(_bb, 12, 8)
    val altitude : Short
        get() {
            val o = __offset(14)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val aggregation : UByte
        get() {
            val o = __offset(16)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    val pressureLevel : Short
        get() {
            val o = __offset(18)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val depth : Short
        get() {
            val o = __offset(20)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val depthTo : Short
        get() {
            val o = __offset(22)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val ensembleMember : Short
        get() {
            val o = __offset(24)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val previousDay : Short
        get() {
            val o = __offset(26)
            return if(o != 0) bb.getShort(o + bb_pos) else 0
        }
    val probability : UByte
        get() {
            val o = __offset(28)
            return if(o != 0) bb.get(o + bb_pos).toUByte() else 0u
        }
    companion object {
        fun validateVersion() = Constants.FLATBUFFERS_25_2_10()
        fun getRootAsVariableWithValues(_bb: ByteBuffer): VariableWithValues = getRootAsVariableWithValues(_bb, VariableWithValues())
        fun getRootAsVariableWithValues(_bb: ByteBuffer, obj: VariableWithValues): VariableWithValues {
            _bb.order(ByteOrder.LITTLE_ENDIAN)
            return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb))
        }
        fun createVariableWithValues(builder: FlatBufferBuilder, variable: UByte, unit: UByte, value: Float, valuesOffset: Int, valuesInt64Offset: Int, altitude: Short, aggregation: UByte, pressureLevel: Short, depth: Short, depthTo: Short, ensembleMember: Short, previousDay: Short, probability: UByte) : Int {
            builder.startTable(13)
            addValuesInt64(builder, valuesInt64Offset)
            addValues(builder, valuesOffset)
            addValue(builder, value)
            addPreviousDay(builder, previousDay)
            addEnsembleMember(builder, ensembleMember)
            addDepthTo(builder, depthTo)
            addDepth(builder, depth)
            addPressureLevel(builder, pressureLevel)
            addAltitude(builder, altitude)
            addProbability(builder, probability)
            addAggregation(builder, aggregation)
            addUnit(builder, unit)
            addVariable(builder, variable)
            return endVariableWithValues(builder)
        }
        fun startVariableWithValues(builder: FlatBufferBuilder) = builder.startTable(13)
        fun addVariable(builder: FlatBufferBuilder, variable: UByte) = builder.addByte(0, variable.toByte(), 0)
        fun addUnit(builder: FlatBufferBuilder, unit: UByte) = builder.addByte(1, unit.toByte(), 0)
        fun addValue(builder: FlatBufferBuilder, value: Float) = builder.addFloat(2, value, 0.0)
        fun addValues(builder: FlatBufferBuilder, values: Int) = builder.addOffset(3, values, 0)
        fun createValuesVector(builder: FlatBufferBuilder, data: FloatArray) : Int {
            builder.startVector(4, data.size, 4)
            for (i in data.size - 1 downTo 0) {
                builder.addFloat(data[i])
            }
            return builder.endVector()
        }
        fun startValuesVector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(4, numElems, 4)
        fun addValuesInt64(builder: FlatBufferBuilder, valuesInt64: Int) = builder.addOffset(4, valuesInt64, 0)
        fun createValuesInt64Vector(builder: FlatBufferBuilder, data: LongArray) : Int {
            builder.startVector(8, data.size, 8)
            for (i in data.size - 1 downTo 0) {
                builder.addLong(data[i])
            }
            return builder.endVector()
        }
        fun startValuesInt64Vector(builder: FlatBufferBuilder, numElems: Int) = builder.startVector(8, numElems, 8)
        fun addAltitude(builder: FlatBufferBuilder, altitude: Short) = builder.addShort(5, altitude, 0)
        fun addAggregation(builder: FlatBufferBuilder, aggregation: UByte) = builder.addByte(6, aggregation.toByte(), 0)
        fun addPressureLevel(builder: FlatBufferBuilder, pressureLevel: Short) = builder.addShort(7, pressureLevel, 0)
        fun addDepth(builder: FlatBufferBuilder, depth: Short) = builder.addShort(8, depth, 0)
        fun addDepthTo(builder: FlatBufferBuilder, depthTo: Short) = builder.addShort(9, depthTo, 0)
        fun addEnsembleMember(builder: FlatBufferBuilder, ensembleMember: Short) = builder.addShort(10, ensembleMember, 0)
        fun addPreviousDay(builder: FlatBufferBuilder, previousDay: Short) = builder.addShort(11, previousDay, 0)
        fun addProbability(builder: FlatBufferBuilder, probability: UByte) = builder.addByte(12, probability.toByte(), 0)
        fun endVariableWithValues(builder: FlatBufferBuilder) : Int {
            val o = builder.endTable()
            return o
        }
    }
}
